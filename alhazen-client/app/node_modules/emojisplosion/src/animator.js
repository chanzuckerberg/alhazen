"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Animator = void 0;
/**
 * Runs the regular gameplay loop of telling actors to animate.
 *
 * Each game "tick" is scheduled using `requestAnimationFrame`.
 * During each tick, each actor is told to `act` with the time elapsed.
 * If it indicates that it's out of bounds, it's removed from the actors array.
 */
class Animator {
    constructor() {
        /**
         * Actors that have been added and not yet marked themselves as out of bounds.
         */
        this.actors = [];
        /**
         * Runs game logic for one tick.
         *
         * @param currentTime   Current time, in milliseconds since page load.
         */
        this.tick = (currentTime) => {
            const timeElapsed = currentTime - this.previousTime;
            for (let i = 0; i < this.actors.length; i += 1) {
                const actor = this.actors[i];
                if (actor.act(timeElapsed)) {
                    actor.dispose();
                    this.actors.splice(i, 1);
                    i -= 1;
                    continue;
                }
            }
            if (this.actors.length === 0) {
                return;
            }
            this.previousTime = currentTime;
            requestAnimationFrame(this.tick);
        };
    }
    /**
     * Adds a new actor to act on each tick.
     *
     * @param actor   Newly created actor to add.
     */
    add(actor) {
        this.actors.push(actor);
    }
    /**
     * Starts gameplay and requests the first tick.
     */
    start() {
        this.previousTime = performance.now();
        requestAnimationFrame(this.tick);
        return this;
    }
}
exports.Animator = Animator;
