"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmojiActor = void 0;
const range_1 = require("./range");
const utils_1 = require("./utils");
/**
 * Pixel distance out of the screen bounds to treat actors as out-of-bounds.
 */
const outOfBounds = 350;
/**
 * Contains the position state and DOM element for a single displayed emoji.
 *
 * @remarks
 * This creates and keeps a single DOM element span in the DOM.
 * Text content for the span is determined by the provided actors.
 *
 * On each game tick, this actor will:
 *  1. Dispose itself if it's moved past out of the game screen
 *  2. Reduce opacity a little bit
 *  3. Dispose itself if it's no longer visible at all
 *  4. Adjust position and velocity as per its physics constants
 *  5. Update the DOM element's opacity and position to reflect those changes
 *
 * "Disposing" an actor means removing its element from the document.
 */
class EmojiActor {
    constructor(settings) {
        /**
         * CSS opacity style, starting at 1 for fully visible.
         */
        this.opacity = 1;
        this.element = document.createElement(settings.tagName);
        this.element.className = settings.className;
        this.element.style.transition = "16ms opacity, 16ms transform";
        this.element.textContent = utils_1.randomArrayMember(settings.emojis);
        // https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/accessible-emoji.md
        this.element.setAttribute("aria-label", "Random emoji");
        this.element.setAttribute("role", "img");
        this.element.style.fontSize = `${range_1.randomInRange(settings.physics.fontSize)}px`;
        this.physics = settings.physics;
        this.position = {
            rotation: range_1.randomInRange(settings.physics.rotation),
            x: settings.position.x,
            y: settings.position.y,
        };
        this.velocity = {
            rotation: range_1.randomInRange(settings.physics.initialVelocities.rotation),
            x: range_1.randomInRange(settings.physics.initialVelocities.x),
            y: range_1.randomInRange(settings.physics.initialVelocities.y),
        };
        this.updateElement();
        settings.process(this.element);
        settings.container.appendChild(this.element);
    }
    /**
     * Moves the actor forward one tick.
     *
     * @param timeElapsed   How many milliseconds have passed since the last action.
     * @returns Whether this is now dead.
     */
    act(timeElapsed) {
        if (this.physics.opacityDecay) {
            this.opacity -= timeElapsed / (this.physics.opacityDecay * this.physics.framerate);
            if (this.opacity <= 0) {
                return true;
            }
        }
        this.velocity.rotation *= this.physics.rotationDeceleration;
        this.velocity.y += this.physics.gravity;
        this.position.rotation += this.velocity.rotation;
        this.position.x += this.velocity.x * timeElapsed / this.physics.framerate;
        this.position.y += this.velocity.y * timeElapsed / this.physics.framerate;
        const windowHeight = window.outerHeight || document.documentElement.clientHeight;
        const windowWidth = window.outerWidth || document.documentElement.clientWidth;
        if (!this.physics.preserveOutOfBounds) {
            if (this.position.y - this.element.clientHeight >
                windowHeight + outOfBounds) {
                return true;
            }
            if (this.position.y + this.element.clientHeight < -outOfBounds) {
                return true;
            }
            if (this.position.x - this.element.clientWidth >
                windowWidth + outOfBounds) {
                return true;
            }
            if (this.position.x + this.element.clientWidth < -outOfBounds) {
                return true;
            }
        }
        this.updateElement();
        return false;
    }
    /**
     * Disposes of the attached DOM element upon actor death.
     */
    dispose() {
        if (this.element.parentElement !== null) {
            this.element.parentElement.removeChild(this.element);
        }
    }
    /**
     * Updates the attached DOM element to match tracking position.
     */
    updateElement() {
        this.element.style.opacity = `${this.opacity}`;
        this.element.style.transform = `translate(${this.position.x}px, ${this.position.y}px) rotate(${Math.round(this.position.rotation)}deg)`;
    }
}
exports.EmojiActor = EmojiActor;
